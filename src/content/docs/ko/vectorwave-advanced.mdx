---
title: "고급 설정"
description: "커스텀 프로퍼티, 동적 태깅, 웹훅, 자동 인젝션, 데이터 아카이빙."
order: 19
category: VectorWave
---

## 커스텀 프로퍼티 (.weaviate_properties)

프로젝트 루트에 `.weaviate_properties` JSON 파일을 생성하여 VectorWave의 기본 스키마를 확장할 수 있습니다:

```json
{
  "team": {
    "data_type": "TEXT",
    "description": "팀 이름",
    "tokenization": "word"
  },
  "priority": {
    "data_type": "INT",
    "description": "우선순위 레벨"
  },
  "region": {
    "data_type": "TEXT",
    "description": "지역",
    "tokenization": "field"
  }
}
```

이 프로퍼티는 `VectorWaveFunctions`, `VectorWaveExecutions`, `VectorWaveGoldenDataset` 컬렉션에 추가됩니다. 데코레이터에서 `**execution_tags`로 사용합니다:

```python
@vectorize(auto=True, team="analytics", priority=1, region="US-WEST")  # custom tags
def process_order(order_id: str, amount: float):
    return {"status": "processed", "order_id": order_id}
```

새 프로퍼티를 추가한 후에는 `update_database_schema()`를 실행하여 기존 컬렉션에 적용하세요.

### 토큰화 옵션

| 토큰화 | 동작 | 사용 사례 |
|---|---|---|
| `"word"` | 공백 기준 분할 | 자연어 텍스트 필드 |
| `"field"` | 전체 값을 하나의 토큰으로 처리 | ID, 코드, 정확 매칭 |
| `"lowercase"` | 단어 분할 + 소문자 변환 | 대소문자 무관 텍스트 |

> **팁:** `order_id`, `user_id` 등의 ID 필드에는 `"field"` 토큰화를 사용하세요. 이렇게 하면 정확 매칭 필터링이 올바르게 동작합니다.

## 동적 실행 태깅

필터링 및 모니터링을 위해 실행에 메타데이터 태그를 추가합니다.

### 글로벌 태그 (환경 변수)

모든 함수에 적용되는 태그를 설정합니다:

```bash
# .env
VECTORWAVE_TAGS_ENVIRONMENT=production
VECTORWAVE_TAGS_REGION=us-east-1
VECTORWAVE_TAGS_VERSION=v2.3.0
```

### 함수 수준 태그 (데코레이터)

```python
@vectorize(
    auto=True,
    team="payments",
    tags={"priority": "high", "sla": "99.9%"},
)
def process_payment(amount: float):
    ...
```

### 태그 병합 규칙

글로벌 태그와 함수 수준 태그가 모두 존재하면, **함수 수준 태그가 우선**합니다:

```
Global:   { environment: "production", region: "us-east-1" }
Function: { environment: "staging", priority: "high" }
Result:   { environment: "staging", region: "us-east-1", priority: "high" }
```

## 실시간 웹훅 알림

에러와 드리프트에 대한 실시간 알림을 받을 수 있도록 웹훅을 설정합니다.

### Discord

```python
from vectorwave import configure_alerts

configure_alerts(
    webhook_url="https://discord.com/api/webhooks/...",
    events=["error", "drift", "healing"],
)
```

Discord 임베드에 포함되는 정보:

- 에러 코드 및 함수 이름
- Trace ID (VectorSurfer로의 클릭 링크)
- 캡처된 속성 및 태그
- 전체 스택 트레이스
- 드리프트 거리 (드리프트 이벤트인 경우)

### Slack

```python
configure_alerts(
    webhook_url="https://hooks.slack.com/services/...",
    format="slack",
    events=["error"],
)
```

### 커스텀 HTTP 엔드포인트

```python
configure_alerts(
    webhook_url="https://your-api.com/vectorwave/alerts",
    format="json",
    headers={"Authorization": "Bearer your-token"},
    events=["error", "drift"],
)
```

## 자동 인젝션

**소스 코드를 수정하지 않고** 기존 모듈에 VectorWave를 주입할 수 있습니다:

```python
from vectorwave import VectorWaveAutoInjector

injector = VectorWaveAutoInjector()

# 모듈의 모든 함수에 @vectorize 주입
injector.inject(
    module="app.services.ai",
    options={
        "auto": True,
        "capture_return_value": True,
        "team": "ai-team",
    },
)

# 이제 app.services.ai의 모든 함수가
# 소스 코드를 한 줄도 바꾸지 않고 벡터화됩니다
```

### 선택적 인젝션

```python
# 특정 함수에만 주입
injector.inject(
    module="app.services.ai",
    include=["generate_response", "embed_query"],
    options={"auto": True},
)

# 특정 함수를 제외하고 모두 주입
injector.inject(
    module="app.services.ai",
    exclude=["internal_helper", "_private_fn"],
    options={"auto": True},
)
```

> **참고:** 자동 인젝션은 import 시점에 동작합니다. 대상 모듈을 import하기 전에 `injector.inject()`를 호출하세요.

## 데이터 아카이빙

오래된 실행 데이터를 장기 저장 또는 LLM 파인튜닝을 위해 내보내고 정리합니다.

### JSONL로 내보내기

```python
from vectorwave import VectorWaveArchiver

archiver = VectorWaveArchiver()

# 실행 데이터를 JSONL로 내보내기 (LLM 파인튜닝 호환)
archiver.export(
    output_path="data/executions.jsonl",
    function_name="generate_response",  # 선택적 필터
    date_range=("2025-01-01", "2025-03-31"),
    golden_only=False,  # Golden만이 아닌 전체 내보내기
)
```

JSONL 형식은 OpenAI 파인튜닝과 호환됩니다:

```json
{"messages": [{"role": "user", "content": "..."}, {"role": "assistant", "content": "..."}]}
```

### 데이터베이스 정리

```python
# 오래된 데이터를 아카이빙하고 Weaviate에서 제거
archiver.archive_and_cleanup(
    older_than_days=90,
    export_path="archive/2025-q1.jsonl",
    keep_golden=True,  # Golden Dataset 항목은 보존
)
```

### 선택적 정리

```python
# 30일 이상된 에러 실행만 제거
archiver.cleanup(
    older_than_days=30,
    filters={"status": "error"},
)
```

## 스키마 마이그레이션

VectorWave 버전 업그레이드 시 Weaviate 스키마가 변경될 수 있습니다:

```python
from vectorwave import update_database_schema

# 무중단 마이그레이션 — 기존 데이터가 보존됩니다
update_database_schema()
```

마이그레이션 과정:
1. 현재 스키마와 필요한 스키마의 차이를 감지
2. 기존 프로퍼티를 삭제하지 않고 새 프로퍼티를 추가
3. 필요 시 데이터 마이그레이션
4. 모든 기존 실행 로그와 Golden Dataset 항목을 보존

## 트레이서 성능 최적화

VectorWave는 내부적으로 `inspect.signature`를 함수 인트로스펙션에 사용합니다. 높은 처리량이 요구되는 애플리케이션에서는 반복적인 리플렉션 오버헤드를 방지하기 위해 LRU Cache로 캐싱됩니다.

별도의 설정이 필요 없으며 이 최적화는 자동으로 적용됩니다.

## 다음 단계

- [API 레퍼런스](/docs/vectorwave-api) -- 전체 파라미터 참조
- [VectorSurfer 대시보드](/docs/vectorsurf-overview) -- 시각적 모니터링
- [기여 가이드](/docs/contributing) -- VectorWave에 기여하는 방법
