---
title: "고급 설정"
description: "커스텀 프로퍼티, 동적 태깅, 웹훅, 자동 인젝션, 데이터 아카이빙."
order: 19
category: VectorWave
---

## 커스텀 프로퍼티 (.weaviate_properties)

프로젝트 루트에 `.weaviate_properties` JSON 파일을 생성하여 VectorWave의 기본 스키마를 확장할 수 있습니다:

```json
{
  "team": {
    "data_type": "TEXT",
    "description": "팀 이름",
    "tokenization": "word"
  },
  "priority": {
    "data_type": "INT",
    "description": "우선순위 레벨"
  },
  "region": {
    "data_type": "TEXT",
    "description": "지역",
    "tokenization": "field"
  }
}
```

이 프로퍼티는 `VectorWaveFunctions`, `VectorWaveExecutions`, `VectorWaveGoldenDataset` 컬렉션에 추가됩니다. 데코레이터에서 `**execution_tags`로 사용합니다:

```python
@vectorize(auto=True, team="analytics", priority=1, region="US-WEST")  # custom tags
def process_order(order_id: str, amount: float):
    return {"status": "processed", "order_id": order_id}
```

새 프로퍼티를 추가한 후에는 `update_database_schema()`를 실행하여 기존 컬렉션에 적용하세요.

### 토큰화 옵션

| 토큰화 | 동작 | 사용 사례 |
|---|---|---|
| `"word"` | 공백 기준 분할 | 자연어 텍스트 필드 |
| `"field"` | 전체 값을 하나의 토큰으로 처리 | ID, 코드, 정확 매칭 |
| `"lowercase"` | 단어 분할 + 소문자 변환 | 대소문자 무관 텍스트 |

> **팁:** `order_id`, `user_id` 등의 ID 필드에는 `"field"` 토큰화를 사용하세요. 이렇게 하면 정확 매칭 필터링이 올바르게 동작합니다.

## 동적 실행 태깅

필터링 및 모니터링을 위해 실행에 메타데이터 태그를 추가합니다.

### 글로벌 태그 (환경 변수)

모든 함수에 적용되는 태그를 설정합니다:

```bash
# .env
VECTORWAVE_TAGS_ENVIRONMENT=production
VECTORWAVE_TAGS_REGION=us-east-1
VECTORWAVE_TAGS_VERSION=v2.3.0
```

### 함수 수준 태그 (데코레이터)

```python
@vectorize(
    auto=True,
    team="payments",
    tags={"priority": "high", "sla": "99.9%"},
)
def process_payment(amount: float):
    ...
```

### 태그 병합 규칙

글로벌 태그와 함수 수준 태그가 모두 존재하면, **함수 수준 태그가 우선**합니다:

```
Global:   { environment: "production", region: "us-east-1" }
Function: { environment: "staging", priority: "high" }
Result:   { environment: "staging", region: "us-east-1", priority: "high" }
```

## 실시간 웹훅 알림

환경 변수로 에러와 드리프트에 대한 실시간 알림을 받을 수 있도록 웹훅을 설정합니다:

```bash
# .env
ALERTER_STRATEGY=webhook
ALERTER_WEBHOOK_URL=https://discord.com/api/webhooks/...
ALERTER_MIN_LEVEL=ERROR
```

알림 페이로드에 포함되는 정보:

- 에러 코드 및 함수 이름
- Trace ID (VectorSurfer로의 클릭 링크)
- 캡처된 속성 및 태그
- 전체 스택 트레이스
- 드리프트 거리 (드리프트 이벤트인 경우)

웹훅 형식은 URL에 따라 자동으로 결정됩니다 (Discord, Slack, 또는 일반 JSON).

## 자동 인젝션

클래스 메서드를 사용하여 **소스 코드를 수정하지 않고** 기존 모듈에 VectorWave를 주입할 수 있습니다:

```python
from vectorwave import VectorWaveAutoInjector

# 모든 inject 호출에 적용할 기본 설정
VectorWaveAutoInjector.configure(
    auto=True,
    capture_return_value=True,
    team="ai-team",
)

# 모듈의 모든 함수에 @vectorize 주입
VectorWaveAutoInjector.inject(
    target_module_path="app.services.ai",
)

# 이제 app.services.ai의 모든 함수가
# 소스 코드를 한 줄도 바꾸지 않고 벡터화됩니다
```

### 재귀적 인젝션

```python
# 모듈과 모든 하위 모듈에 주입
VectorWaveAutoInjector.inject(
    target_module_path="app.services",
    recursive=True,
    auto=True,  # inject 호출별 설정 오버라이드
)
```

> **참고:** 자동 인젝션은 import 시점에 동작합니다. 대상 모듈을 import하기 전에 `VectorWaveAutoInjector.inject()`를 호출하세요.

## 스키마 마이그레이션

VectorWave 버전 업그레이드 시 Weaviate 스키마가 변경될 수 있습니다:

```python
from vectorwave import update_database_schema

# 무중단 마이그레이션 — 기존 데이터가 보존됩니다
update_database_schema()
```

마이그레이션 과정:
1. 현재 스키마와 필요한 스키마의 차이를 감지
2. 기존 프로퍼티를 삭제하지 않고 새 프로퍼티를 추가
3. 필요 시 데이터 마이그레이션
4. 모든 기존 실행 로그와 Golden Dataset 항목을 보존

## 민감 데이터 마스킹

VectorWave는 캡처된 입출력에서 민감한 필드를 자동으로 마스킹합니다. 기본적으로 `password`, `api_key`, `token`, `secret`, `auth_token`이라는 이름의 필드가 `***MASKED***`로 대체됩니다.

환경 변수로 목록을 커스터마이징할 수 있습니다:

```bash
# .env
SENSITIVE_FIELD_NAMES=password,api_key,token,secret,auth_token,ssn,credit_card
```

마스킹은 `@vectorize`와 `@trace_span` 모두의 실행 로그에 적용됩니다.

## 비동기 로깅

지연시간에 민감한 애플리케이션에서는 비동기 DB 로깅을 활성화하여 함수 실행을 블로킹하지 않을 수 있습니다:

```bash
# .env
ASYNC_LOGGING=True
```

활성화되면 실행 로그가 큐에 쌓이고 백그라운드 스레드에서 Weaviate에 기록됩니다. 함수는 DB 쓰기를 기다리지 않고 즉시 반환합니다.

> **참고:** 비동기 로깅은 큐가 플러시되기 전에 프로세스가 크래시하면 데이터를 잃을 수 있습니다. 중요한 `@trace_span` 호출에는 `force_sync=True`를 사용하여 오버라이드하세요.

## 배치 성능 튜닝

VectorWave는 효율성을 위해 Weaviate에 대한 쓰기를 배치 처리합니다. 배치 동작을 조절할 수 있습니다:

```bash
# .env
BATCH_THRESHOLD=20          # 이 객체 수에 도달하면 플러시 (기본값: 20)
FLUSH_INTERVAL_SECONDS=2.0  # 최소 N초마다 플러시 (기본값: 2.0)
```

- **`BATCH_THRESHOLD` 높이기**: 쓰기 호출 횟수는 줄지만 메모리 사용량과 지연시간이 높아짐
- **`BATCH_THRESHOLD` 낮추기**: 더 자주 쓰기가 발생하지만 지연시간이 줄어듦

## 토큰 사용량 추적

VectorWave는 `VectorWaveTokenUsage` 컬렉션에서 LLM 토큰 사용량을 추적합니다. 집계 통계를 확인할 수 있습니다:

```python
from vectorwave import get_token_usage_stats

stats = get_token_usage_stats()
# { "total_tokens": 125000, "by_category": { "embedding": 80000, "completion": 45000 } }
```

> **VectorSurfer**: 토큰 사용량은 [VectorSurfer 대시보드](/docs/vectorsurf-features)에서 도넛 차트 위젯으로 시각화됩니다.

## 데이터 아카이빙 (VectorWaveArchiver)

대규모 배포에서는 오래된 실행 데이터를 아카이빙하여 Weaviate 성능을 유지할 수 있습니다. 아카이버는 고급 import입니다 (퍼블릭 API의 일부가 아님):

```python
from vectorwave.database.archiver import VectorWaveArchiver

archiver = VectorWaveArchiver()

# 오래된 데이터를 스냅샷 파일로 내보내고 Weaviate에서 삭제
archiver.export_and_clear(
    older_than_days=30,
    mode="archive",   # "snapshot" (내보내기만) | "archive" (내보내기 + 삭제) | "purge" (삭제만)
    output_path="./archives/",
)
```

## 함수 캐시

VectorWave는 등록된 함수 메타데이터를 `.vectorwave_functions_cache.json`에 로컬 캐싱합니다. 함수 코드가 변경되지 않았을 때 시작 시 불필요한 Weaviate 쿼리를 방지합니다.

캐시는 다음의 경우 자동으로 무효화됩니다:
- 함수 소스 코드가 변경될 때
- `.weaviate_properties`가 수정될 때
- `update_database_schema()`가 호출될 때

강제 재등록이 필요하면 캐시 파일을 수동으로 삭제하세요.

## Rust 코어 (선택사항)

VectorWave는 성능이 중요한 작업을 위해 [PyO3](https://pyo3.rs/) 기반의 선택적 Rust 가속 코어를 포함합니다:

- **배치 매니저** — Weaviate에 대한 고처리량 배치 쓰기
- **데이터 마스킹** — 대용량 페이로드에 대한 빠른 필드 수준 마스킹

Rust 확장을 사용할 수 없는 환경(예: 미지원 플랫폼)에서는 자동으로 순수 Python 구현으로 폴백합니다. 별도의 설정이 필요 없습니다.

## 트레이서 성능 최적화

VectorWave는 내부적으로 `inspect.signature`를 함수 인트로스펙션에 사용합니다. 높은 처리량이 요구되는 애플리케이션에서는 반복적인 리플렉션 오버헤드를 방지하기 위해 LRU Cache로 캐싱됩니다.

별도의 설정이 필요 없으며 이 최적화는 자동으로 적용됩니다.

## 다음 단계

- [API 레퍼런스](/docs/vectorwave-api) -- 전체 파라미터 참조
- [VectorSurfer 대시보드](/docs/vectorsurf-overview) -- 시각적 모니터링
- [기여 가이드](/docs/contributing) -- VectorWave에 기여하는 방법
