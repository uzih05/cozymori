---
title: "@vectorize 코어"
description: "함수 벡터화, 추적, 저장을 담당하는 핵심 데코레이터."
order: 12
category: VectorWave
---

## @vectorize 데코레이터

`@vectorize`는 VectorWave의 핵심 프리미티브입니다. 하나의 데코레이터로 모든 Python 함수를 **벡터화, 추적, 검색 가능한** 실행 단위로 변환합니다.

```python
from vectorwave import vectorize

@vectorize(
    semantic_cache=True,
    cache_threshold=0.95,
    capture_return_value=True,
    team="ml-team"  # custom tag
)
async def generate_response(query: str):
    return await llm.complete(query)
```

## 동작 원리

데코레이터가 적용된 함수가 호출되면, VectorWave는 다음 과정을 수행합니다:

### 1. 정적 등록

최초 import 시, VectorWave는 함수의 **정적 메타데이터**를 캡처하여 `VectorWaveFunctions`에 저장합니다:

- 함수 이름, 모듈 경로, 정규화된 전체 이름
- 소스 코드 (`inspect.getsource` 사용)
- 독스트링
- AI 생성 설명 (`auto=True`인 경우)
- 검색 설명 (제공된 경우)
- 커스텀 프로퍼티 (`.weaviate_properties`로 정의된 경우)

### 2. 실행 인터셉션

각 호출마다 데코레이터는 다음을 수행합니다:

1. 분산 트레이싱을 위한 `trace_id`와 `span_id`를 생성
2. 입력을 임베딩 벡터로 변환
3. 시맨틱 캐시 히트 확인 (`semantic_cache=True`인 경우)
4. 캐시 히트 시 캐시된 결과를 ~0.02초 만에 반환
5. 캐시 미스 시 함수를 정상 실행
6. 실행 로그를 `VectorWaveExecutions`에 저장

### 3. 에러 처리

함수에서 예외가 발생하면:

1. 전체 스택 트레이스와 함께 에러를 캡처
2. `status: "error"`로 Weaviate에 저장
3. [자동 치유](/docs/vectorwave-healing) 진단 및 자동 수정에 활용 가능

## 동기/비동기 지원

VectorWave는 동기 함수와 비동기 함수를 모두 지원합니다:

```python
# 동기 함수
@vectorize(auto=True)
def sync_function(query: str):
    return process(query)

# 비동기 함수
@vectorize(auto=True)
async def async_function(query: str):
    return await async_process(query)
```

## 분산 트레이싱

### 루트 스팬

모든 `@vectorize` 호출은 고유한 `trace_id`를 가진 **루트 스팬**을 생성합니다:

```python
@vectorize(auto=True)
def parent_function(data):
    result_a = child_function_a(data)
    result_b = child_function_b(result_a)
    return result_b
```

### @trace_span을 활용한 자식 스팬

`@trace_span`을 사용하여 내부 함수를 자식 스팬으로 추적할 수 있습니다:

```python
from vectorwave import vectorize, trace_span

@vectorize(auto=True)
def pipeline(query: str):
    embedding = embed(query)
    result = search(embedding)
    return format_result(result)

@trace_span
def embed(query: str):
    return model.encode(query)

@trace_span
def search(embedding):
    return db.query(embedding, limit=10)

@trace_span
def format_result(result):
    return {"items": result, "count": len(result)}
```

`@trace_span`은 세밀한 제어를 위한 선택적 파라미터도 지원합니다:

```python
@trace_span(capture_return_value=True, attributes_to_capture=["score"])
def rank_results(results, score=0.5):
    return sorted(results, key=lambda x: x["score"])
```

모든 `@trace_span` 파라미터는 [API 레퍼런스](/docs/vectorwave-api)를 참고하세요.

모든 자식 스팬은 부모의 `trace_id`를 공유하여 계층적 트레이스를 구성합니다:

```
pipeline (trace_id: abc-123, span_id: 001)
├── embed (trace_id: abc-123, span_id: 002)
├── search (trace_id: abc-123, span_id: 003)
└── format_result (trace_id: abc-123, span_id: 004)
```

> **VectorSurfer**: 분산 트레이스는 [VectorSurfer 대시보드](/vectorsurf)에서 인터랙티브 워터폴 다이어그램으로 시각화됩니다 — 스팬을 클릭하면 입력, 출력, 소요 시간을 확인할 수 있습니다.

### 트레이스 조회

트레이스 데이터는 VectorWave의 실행 검색을 통해 조회할 수 있습니다:

```python
from vectorwave import search_executions

# 특정 트레이스의 모든 실행 조회
spans = search_executions(
    filters={"trace_id": "abc-123"},
    sort_by="timestamp_utc",
)
for span in spans:
    print(f"{span['function_name']} — {span['duration_ms']}ms")
```

## 자동 동작

일부 `@vectorize` 옵션은 다른 기능을 자동으로 활성화합니다:

- **`semantic_cache=True`** — `capture_return_value=True`가 자동 활성화됩니다. 캐시된 결과를 반환하려면 반환값이 저장되어 있어야 합니다.
- **`replay=True`** — `capture_return_value=True`와 모든 함수 인자 캡처가 자동 활성화됩니다. 리플레이 테스트에는 전체 입출력 데이터가 필요합니다.

즉, 캐싱이나 리플레이를 사용할 때 `capture_return_value=True`를 수동으로 설정할 필요가 없습니다.

## 실행 상태값

각 실행은 다음 상태값 중 하나로 저장됩니다:

| 상태 | 설명 |
|---|---|
| `SUCCESS` | 함수가 정상 완료 |
| `ERROR` | 예외 발생, 알림 전송 (설정된 경우) |
| `FAILURE` | 예외 발생, `.vtwignore`로 억제됨 |
| `CACHE_HIT` | 시맨틱 캐시에서 결과 반환 |
| `ANOMALY` | 드리프트 감지 — 입력이 정상 패턴에서 벗어남 |

이 값을 사용하여 실행을 필터링할 수 있습니다:

```python
from vectorwave import search_executions

errors = search_executions(filters={"status": "ERROR"}, limit=10)
anomalies = search_executions(filters={"status": "ANOMALY"}, limit=10)
```

## 입력 캡처 모드

### 수동 모드 (기본값)

기본적으로 VectorWave는 명시적으로 전달한 것만 캡처합니다:

```python
@vectorize(auto=True)
def process(query: str, context: dict):
    # 함수 이름과 실행 메타데이터만 저장됩니다
    return llm.complete(query, context=context)
```

### 자동 캡처

`capture_inputs=True`를 설정하면 모든 함수 파라미터가 자동으로 저장됩니다:

```python
@vectorize(capture_inputs=True, auto=True)
def process(query: str, context: dict):
    # 'query'와 'context' 모두 Weaviate에 저장됩니다
    return llm.complete(query, context=context)
```

### 반환값 캡처

`capture_return_value=True`를 설정하면 함수의 반환값도 저장됩니다:

```python
@vectorize(capture_return_value=True, auto=True)
def process(query: str):
    result = llm.complete(query)
    return result  # 이 값이 Weaviate에 저장됩니다
```

## AI 자동 문서화

`auto=True`를 설정하면 VectorWave가 LLM을 사용하여 자동으로 생성합니다:

- 사람이 읽을 수 있는 함수 설명
- RAG 쿼리에 최적화된 검색 메타데이터

```python
@vectorize(auto=True)
def calculate_risk_score(portfolio: dict, market_data: dict):
    # VectorWave가 자동 생성하는 예시:
    # "주어진 투자 포트폴리오의 현재 시장 데이터 상황에 기반한
    #  리스크 점수를 계산합니다."
    ...
```

## 커스텀 실행 태그

필터링 및 모니터링을 위해 함수에 커스텀 메타데이터를 태깅합니다. 태그는 `**execution_tags`로 전달되며, `.weaviate_properties` 파일에 정의되어 있어야 합니다:

```python
@vectorize(team="ml-team", auto=True)  # custom tag
def ml_function():
    ...

@vectorize(team="backend-team", priority="high", auto=True)  # custom tags
def backend_function():
    ...
```

커스텀 태그는 함수 메타데이터와 실행 로그 모두에 저장되어, [VectorSurfer 대시보드](/vectorsurf)와 검색 API에서 필터링할 수 있습니다. `.weaviate_properties` 설정은 [고급 설정](/docs/vectorwave-advanced)을 참고하세요.

## 다음 단계

- [시맨틱 캐싱](/docs/vectorwave-caching) -- 캐싱 심화 학습
- [자동 치유](/docs/vectorwave-healing) -- 자동 에러 진단 및 수정
- [API 레퍼런스](/docs/vectorwave-api) -- 전체 파라미터 참조
