---
title: "API 레퍼런스"
description: "@vectorize 옵션, 환경 변수, 유틸리티 클래스의 완전한 참조."
order: 20
category: VectorWave
---

## @vectorize 파라미터

| 파라미터 | 타입 | 기본값 | 설명 |
|---|---|---|---|
| `semantic_cache` | `bool` | `False` | 유사한 입력에 대한 시맨틱 캐싱 활성화 |
| `cache_threshold` | `float` | `0.9` | 캐시 히트를 위한 코사인 유사도 임계값 (0.0 -- 1.0) |
| `semantic_cache_filters` | `Dict` | `None` | 시맨틱 캐시 조회용 정적 필터 |
| `semantic_cache_scope` | `List[str]` | `None` | 동적 캐시 필터로 사용할 함수 파라미터 이름 |
| `capture_return_value` | `bool` | `False` | 함수 반환값을 Weaviate에 저장 |
| `capture_inputs` | `bool` | `False` | 모든 함수 파라미터를 자동 캡처 |
| `attributes_to_capture` | `List[str]` | `None` | 로깅할 특정 속성 |
| `replay` | `bool` | `False` | 리플레이 기반 회귀 테스트 활성화 |
| `auto` | `bool` | `False` | LLM을 통한 함수 설명 자동 생성 |
| `search_description` | `str` | `None` | 벡터 검색 최적화를 위한 커스텀 설명 |
| `sequence_narrative` | `str` | `None` | 컨텍스트 이해를 위한 스토리/내러티브 |
| `**execution_tags` | `kwargs` | — | `.weaviate_properties`에 정의된 커스텀 태그 (예: `team="ml-team"`) |

### 사용법

```python
@vectorize(
    semantic_cache=True,
    cache_threshold=0.95,
    capture_return_value=True,
    capture_inputs=True,
    replay=True,
    auto=True,
    team="ml-team",  # custom tag (.weaviate_properties에 정의)
)
async def generate_response(query: str):
    return await llm.complete(query)
```

## @trace_span

자식 스팬 트레이싱을 위한 데코레이터입니다. `@vectorize` 부모 컨텍스트 내에서 사용해야 합니다.

```python
from vectorwave import trace_span

@trace_span
def child_function(data):
    return process(data)
```

부모 `@vectorize` 호출의 `trace_id`를 자동으로 상속받습니다.

### 선택적 파라미터

`@trace_span`은 세밀한 제어를 위한 키워드 인자도 지원합니다:

| 파라미터 | 타입 | 기본값 | 설명 |
|---|---|---|---|
| `attributes_to_capture` | `List[str]` | `None` | 이 스팬에 로깅할 특정 속성 |
| `capture_return_value` | `bool` | `False` | 스팬의 반환값 저장 |
| `force_sync` | `bool` | `False` | 동기 DB 쓰기 강제 (비동기 로깅 무시) |

```python
@trace_span(capture_return_value=True, attributes_to_capture=["score"])
def rank_results(results, score=0.5):
    return sorted(results, key=lambda x: x["score"])
```

## 환경 변수

### 연결

| 변수 | 필수 여부 | 기본값 | 설명 |
|---|---|---|---|
| `WEAVIATE_HOST` | 아니오 | `localhost` | Weaviate 호스트명 |
| `WEAVIATE_PORT` | 아니오 | `8080` | Weaviate HTTP 포트 |
| `WEAVIATE_GRPC_PORT` | 아니오 | `50051` | Weaviate gRPC 포트 |
| `WEAVIATE_API_KEY` | WCS용 | -- | Weaviate Cloud API 키 |

### 벡터라이저

| 변수 | 필수 여부 | 기본값 | 설명 |
|---|---|---|---|
| `VECTORIZER` | 아니오 | `weaviate_module` | 임베딩 제공자: `weaviate_module`, `openai_client`, `huggingface`, `none` |
| `OPENAI_API_KEY` | AI 기능에 필요 | -- | 임베딩, 자동 문서화, 치유, RAG용 OpenAI API 키 |
| `HF_MODEL_NAME` | 아니오 | `sentence-transformers/all-MiniLM-L6-v2` | `huggingface` 벡터라이저용 HuggingFace 모델 |
| `WEAVIATE_VECTORIZER_MODULE` | 아니오 | `text2vec-openai` | Weaviate 내장 벡터라이저 모듈명 |
| `WEAVIATE_GENERATIVE_MODULE` | 아니오 | `generative-openai` | Weaviate 생성 모듈명 |

### GitHub (자동 치유)

| 변수 | 필수 여부 | 기본값 | 설명 |
|---|---|---|---|
| `GITHUB_TOKEN` | 자동 PR에 필요 | -- | GitHub 개인 접근 토큰 |
| `GITHUB_REPO_NAME` | 자동 PR에 필요 | -- | GitHub 리포지토리 (형식: `org/repo`) |
| `GITHUB_BASE_BRANCH` | 아니오 | `main` | 자동 PR 대상 브랜치 |

### 드리프트 감지 및 알림

| 변수 | 필수 여부 | 기본값 | 설명 |
|---|---|---|---|
| `DRIFT_DETECTION_ENABLED` | 아니오 | `False` | 드리프트 감지 활성화 |
| `DRIFT_DISTANCE_THRESHOLD` | 아니오 | `0.25` | 드리프트 알림 거리 임계값 |
| `DRIFT_NEIGHBOR_AMOUNT` | 아니오 | `5` | KNN 드리프트 검사 이웃 수 |
| `ALERTER_STRATEGY` | 아니오 | `none` | 알림 전략: `none` 또는 `webhook` |
| `ALERTER_WEBHOOK_URL` | 알림용 | -- | 알림 웹훅 URL (Discord, Slack 등) |
| `ALERTER_MIN_LEVEL` | 아니오 | `ERROR` | 최소 알림 레벨 |

### 성능 튜닝

| 변수 | 필수 여부 | 기본값 | 설명 |
|---|---|---|---|
| `BATCH_THRESHOLD` | 아니오 | `20` | 배치 플러시 전 객체 수 |
| `FLUSH_INTERVAL_SECONDS` | 아니오 | `2.0` | 배치 플러시 시간 간격 (초) |
| `ASYNC_LOGGING` | 아니오 | `False` | 낮은 지연시간을 위한 비동기 DB 로깅 |

### 파일 경로

| 변수 | 필수 여부 | 기본값 | 설명 |
|---|---|---|---|
| `CUSTOM_PROPERTIES_FILE_PATH` | 아니오 | `.weaviate_properties` | 커스텀 스키마 프로퍼티 파일 |
| `IGNORE_ERROR_FILE_PATH` | 아니오 | `.vtwignore` | 에러 억제 파일 |
| `FAILURE_MAPPING_FILE_PATH` | 아니오 | `.vectorwave_errors.json` | 에러 코드 매핑 파일 |

### 데이터 및 태그

| 변수 | 필수 여부 | 기본값 | 설명 |
|---|---|---|---|
| `SENSITIVE_FIELD_NAMES` | 아니오 | `password,api_key,token,secret,auth_token` | 로그에서 마스킹할 쉼표 구분 필드명 |
| `RECOMMENDATION_STEADY_MARGIN` | 아니오 | `0.05` | Golden Dataset 추천 STEADY 마진 |
| `RECOMMENDATION_DISCOVERY_MARGIN` | 아니오 | `0.15` | Golden Dataset 추천 DISCOVERY 마진 |
| `VECTORWAVE_TAGS_*` | 아니오 | -- | 글로벌 태그 (예: `VECTORWAVE_TAGS_ENV=production`) |

## 핵심 함수

### initialize_database()

네 개의 Weaviate 컬렉션(`VectorWaveFunctions`, `VectorWaveExecutions`, `VectorWaveGoldenDataset`, `VectorWaveTokenUsage`)을 생성합니다. 최초 사용 전 한 번 호출해야 합니다.

```python
from vectorwave import initialize_database
initialize_database()
```

### update_database_schema()

VectorWave 업그레이드 시 무중단 스키마 마이그레이션을 수행합니다.

```python
from vectorwave import update_database_schema
update_database_schema()
```

### search_functions(query, limit)

저장된 함수 메타데이터에 대한 벡터 검색입니다.

```python
from vectorwave import search_functions

results = search_functions(query="authentication", limit=5)
```

### search_executions(limit, filters, sort_by, sort_ascending)

필터링과 정렬을 사용한 실행 로그 검색입니다. `search_functions`와 달리 벡터 검색이 아닌 필터 기반 조회를 사용합니다.

```python
from vectorwave import search_executions

# 최근 에러 조회
results = search_executions(
    limit=10,
    filters={"status": "ERROR", "duration_ms__gte": 100},
    sort_by="timestamp_utc",
    sort_ascending=False,
)
```

필터 연산자: 정확 매칭 (기본값), `__not_equal`, `__gte`, `__gt`, `__lte`, `__lt`, `__like`.

### search_functions_hybrid(query, limit, filters, alpha)

함수 정의에 대한 하이브리드 검색 (키워드 + 벡터)입니다.

```python
from vectorwave import search_functions_hybrid

results = search_functions_hybrid(
    query="calculate loyalty points",
    limit=5,
    alpha=0.5,  # 0.0 = 순수 키워드, 1.0 = 순수 벡터
)
```

### search_errors_by_message(query, limit, filters)

에러 메시지에 대한 시맨틱 검색입니다. 벡터 유사도를 사용하여 자연어 설명과 매칭되는 에러를 찾습니다.

```python
from vectorwave import search_errors_by_message

results = search_errors_by_message(
    query="timeout connecting to database",
    limit=10,
    filters={"function_name": "generate_response"},
)
```

### generate_and_register_metadata()

`auto=True`가 설정된 모든 등록 함수에 대해 LLM 기반 메타데이터 생성을 트리거합니다. 초기 설정 후 설명을 일괄 생성하는 데 유용합니다.

```python
from vectorwave import generate_and_register_metadata

generate_and_register_metadata()
```

### search_and_answer(query)

코드베이스에 대한 RAG 기반 Q&A입니다.

```python
from vectorwave import search_and_answer

answer = search_and_answer("How does the auth flow work?")
```

### analyze_trace_log(trace_id, question)

자연어 질문으로 특정 트레이스를 분석합니다.

```python
from vectorwave import analyze_trace_log

analysis = analyze_trace_log(
    trace_id="abc-123",
    question="Why was this trace slow?",
)
```

## VectorWaveHealer

### 생성자

```python
from vectorwave import VectorWaveHealer

healer = VectorWaveHealer(
    model="gpt-4-turbo",     # LLM 모델 (유일한 파라미터)
)
```

### diagnose_and_heal()

```python
result = healer.diagnose_and_heal(
    function_name="generate_response",
    lookback_minutes=60,      # 최근 N분 내 에러 검색
    create_pr=True,           # 수정 사항으로 GitHub PR 생성
)
# Returns: str (LLM이 제안한 수정 코드 또는 에러 메시지)
```

## VectorWaveReplayer

### 생성자

```python
from vectorwave import VectorWaveReplayer
replayer = VectorWaveReplayer()
```

### replay()

```python
results = replayer.replay(
    function_full_name="app.generate_response",
    limit=20,                 # 리플레이할 최대 실행 수
    update_baseline=False,    # 불일치 시 베이스라인 업데이트
)
# Returns: { function, total, passed, failed, updated, failures }
```

시맨틱 비교를 사용하려면 `SemanticReplayer`를 사용하세요:

```python
from vectorwave import SemanticReplayer

semantic_replayer = SemanticReplayer()
results = semantic_replayer.replay(
    function_full_name="app.generate_response",
    limit=20,
    similarity_threshold=0.85,  # 벡터 유사도 임계값
    semantic_eval=True,          # LLM 기반 시맨틱 평가 사용
)
```

## VectorWaveDatasetManager

### 생성자

```python
from vectorwave import VectorWaveDatasetManager
dm = VectorWaveDatasetManager()
```

### register_as_golden()

```python
dm.register_as_golden(
    log_uuid="abc-123",
    note="Verified by QA",
    tags=["v2", "production"],
)
```

### recommend_candidates()

```python
candidates = dm.recommend_candidates(
    function_name="generate_response",
    limit=5,
)
```

## VectorWaveAutoInjector

자동 인젝션은 클래스 메서드를 사용합니다 — 인스턴스 생성이 필요 없습니다.

### configure()

```python
from vectorwave import VectorWaveAutoInjector

# 모든 inject 호출에 적용할 기본 설정
VectorWaveAutoInjector.configure(
    auto=True,
    capture_return_value=True,
    team="ai-team",
)
```

### inject()

```python
# 모듈의 모든 함수에 @vectorize 주입
VectorWaveAutoInjector.inject(
    target_module_path="app.services.ai",
    recursive=False,          # 하위 모듈도 재귀적으로 스캔
    team="ai-team",           # inject 호출별 설정 오버라이드
)
```

## 웹훅 알림

알림은 함수 호출이 아닌 환경 변수로 설정합니다:

```bash
# .env
ALERTER_STRATEGY=webhook                              # 웹훅 알림 활성화
ALERTER_WEBHOOK_URL=https://discord.com/api/webhooks/...  # 웹훅 엔드포인트
ALERTER_MIN_LEVEL=ERROR                               # 최소 알림 레벨
DRIFT_DETECTION_ENABLED=True                          # 드리프트 알림 활성화
DRIFT_DISTANCE_THRESHOLD=0.25                         # 드리프트 임계값
```

에러 또는 드리프트 이벤트 발생 시 알림 페이로드가 자동으로 전송됩니다.
